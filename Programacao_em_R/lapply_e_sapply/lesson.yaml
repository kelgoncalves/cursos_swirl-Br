- Class: meta
  Course: Programacao em R
  Lesson: lapply e sapply
  Author: Nick Carchedi, Clarice Groeneveld (tradução)
  Type: Standard
  Organization: JHU Biostat
  Version: 2.2.11

- Class: text
  Output: Nessa lição, você irá aprender a user lapply() e sapply(), os dois membros mais importantes da família *apply de funções, também conhecidas como funções de loop.

- Class: text
  Output: Essas funções poderosas, junto com seus parentes próximos (vapply() e tapply(), entre outras) provêm uma maneira concisa e conveniente de implementar a estratégia Dividir-Aplicar-Combinar para análise de dados.

- Class: text
  Output: Cada uma das funções *apply irá DIVIDIR os dados em pedaços menores, APLICAR uma função a cada pedaço, e então COMBINAR os resultados. Uma discussão mais detalhada desta estratégia pode ser encontrada no artigo de Hadley Wickham no  Journal of Statistical Software entitulado  'The Split-Apply-Combine Strategy for Data Analysis'.

- Class: text
  Output: Ao longo desta lição, utilizaremos um conjunto de dados chamado bandeiras (Bandeiras) do repositório UCI Machine Learning. Este conjunto de dados contém detalhes sobre várias nações e suas bandeiras. Mais informação (em inglês) pode ser encontrada neste link:  http://archive.ics.uci.edu/ml/datasets/bandeiras

- Class: text
  Output: Vamos começar logo para que você possa ter uma noção de como essas funções especiais funcionam!

- Class: cmd_question
  Output: Colocamos um conjunto de dados em uma variável chamada bandeiras. Digite head(bandeiras) para visualizar as seis primeiras linhas (a 'cabeça') do dataset.
  CorrectAnswer: head(bandeiras)
  AnswerTests: omnitest(correctExpr='head(bandeiras)')
  Hint: Digite head(bandeiras) para ver a 'cabeça' do dataset.

- Class: cmd_question
  Output: Você pode precisar rolar a tela para cima para ver todo o resultado. Agora, vamos checar as dimensões do dataset usando dim(bandeiras).
  CorrectAnswer: dim(bandeiras)
  AnswerTests: omnitest(correctExpr='dim(bandeiras)')
  Hint: Digite dim(bandeiras) para ver as dimensões do dataset.

- Class: text
  Output: Isso nos diz que há 194 linhas, ou observações, e 30 colunas, ou variáveis. Cada observação é um país e cada variável descreve uma característica daquele país e sua bandeira. Se quiser, há uma uma descrição mais completa do dataset que pode ser aberta em um arquivo de texto separado digitando viewinfo() quando estiver de volta ao prompt (>).

- Class: cmd_question
  Output: Como com qualquer dataset, gostaríamos de saber em que formato as variáveis estão armazenadas. Em outras palavras, qual é a classe de cada variável? O que acontece se nós digitarmos class(bandeiras)? Teste isso.
  CorrectAnswer: class(bandeiras)
  AnswerTests: omnitest(correctExpr='class(bandeiras)')
  Hint: Digite class(bandeiras) para ver o que acontece.

- Class: text
  Output: Isso só nos diz que o dataset inteiro é armazenado como 'data.frame', o que não responde nossa pergunta. O que realmente queremos é chamar a função classe em cada coluna individualmente. Embora pudessemos fazer isso manualmente (uma coluna de cada vez), é muito mais rápido se pudermos automatizar o processo. Parece que precisamos de um loop!

- Class: text
  Output: A função lapply() utiliza uma lista como input, aplica uma função a cada elemento da lista, então retorna uma lista de mesmo tamanho que a original. Já que um data.frame é nada mais que uma lista de vetores (você pode visualizar isso com as.list(bandeiras)), podemos usar lapply para aplicar a função class() a cada coluna do dataset de bandeiras. Vamos vê-la em ação!

- Class: cmd_question
  Output: Digite lista_cls <- lapply(bandeiras, class) para aplicar a função class() a cada coluna do dataset de bandeiras e armazenar o resultado em uma variável chamada lista_cls. Note que você provê apenas o nome da função que você quer chamar (nesse exemplo, class), sem o parênteses depois do nome.
  CorrectAnswer: lista_cls <- lapply(bandeiras, class)
  AnswerTests: omnitest(correctExpr='lista_cls <- lapply(bandeiras, class)')
  Hint: Digite lista_cls <- lapply(bandeiras, class) para aplicar a função class() a cada coluna do nosso dataset e armazenar o resultado em uma variável chamada lista_cls.

- Class: cmd_question
  Output: Digite lista_cls para ver o resultado.
  CorrectAnswer: lista_cls
  AnswerTests: omnitest(correctExpr='lista_cls')
  Hint: Digite lista_cls para ver o resultado.

- Class: cmd_question
  Output: O 'l' em 'lapply' vem de 'lista'. Digite class(lista_cls) para confirmar que lapply() retornou uma lista.
  CorrectAnswer: class(lista_cls)
  AnswerTests: omnitest(correctExpr='class(lista_cls)')
  Hint: Digite class(lista_cls) para confirmar que lapply() retornou uma lista.

- Class: text
  Output: Como esperado, temos uma lista de comprimento 30 -- um elemento para cada variável/coluna. A saída seria consideravelmente mais compacta se pudéssemos representá-la como um vetor ao invés de uma lista.

- Class: cmd_question
  Output: Você deve se lembrar de uma lição anterior que listas são mais úteis para armazenar dados com múltiplas classes. Neste caso, já que todos os elementos da lista retornada por lapply() são vetores de caracteres de tamanho um (como “integer” e “vector”), lista_cls pode ser simplificada a um vetor de caracteres. Para fazer isso manualmente, digite as.character(lista_cls)
  CorrectAnswer: as.character(lista_cls)
  AnswerTests: omnitest(correctExpr='as.character(lista_cls)')
  Hint: Digite as.character(lista_cls) para coagir lista_cls a um vetor de caracteres.

- Class: cmd_question
  Output: sapply() permite que você automatize esse processo, chamando lapply() por trás da cortina, mas então tentando simplificar (o 's' em 'sapply') o resultado para você. Use sapply() da mesma maneira que você usou lapply() para obter a classe de cada coluna do dataset bandeiras e armazene o resultado em vect_cls. Se precisar de ajuda, digite ?sapply para abrir a documentação.
  CorrectAnswer: vect_cls <- sapply(bandeiras, class)
  AnswerTests: omnitest(correctExpr='vect_cls <- sapply(bandeiras, class)')
  Hint: Digite vect_cls <- sapply(bandeiras, class) para armazenar as classes das colunas em um vetor de caracteres chamado vect_cls.

- Class: cmd_question
  Output: Use class(vect_cls) para confirmar que sapply() simplificou o resultado a um vetor de caracteres.
  CorrectAnswer: class(vect_cls)
  AnswerTests: omnitest(correctExpr='class(vect_cls)')
  Hint: Digite class(vect_cls)  para confirmar que sapply() retornou um vetor de caracteres.

- Class: text
  Output: Em geral, se o resultado é uma lista onde todos os elementos são de comprimento um, sapply() retorna um vetor. Se o resultado é uma lista em que cada elemento é um vetor de mesmo tamanho (> 1), sapply() retorna uma matriz. Se sapply() não souber o que fazer, então ele retorna uma lista da mesma maneira que lapply() faria.

- Class: text
  Output: Vamos praticar o uso de lapply() e sapply() mais um pouquinho!

- Class: text
  Output: As colunas 11 a 17 do nosso dataset são variáveis indicadores, cada uma representado uma cor diferente. O valor da variável indicadora é 1 se a cor estiver presente na bandeira do país e 0 se não estiver.

- Class: cmd_question
  Output:  Portanto, se quisermos saber o número total de países (nos nossos dados) com, por exemplo, a cor laranja em sua bandeira, podemos só adicionar os 1s e 0s na coluna 'orange' (laranja). Teste sum(bandeiras$orange) para ver isso.
  CorrectAnswer: sum(bandeiras$orange)
  AnswerTests: omnitest(correctExpr='sum(bandeiras$orange)')
  Hint: Use sum(bandeiras$orange) para adicionar 1s e 0s na coluna 'orange'.

- Class: text
  Output: Agora, queremos repetir essa operação para cada uma das cores avaliadas nos dados.

- Class: cmd_question
  Output: Primeiro, use cores_bandeiras ← bandeiras[,11:17] para extrair as colunas contendo dados de cores e armazene em um novo data.frame chamado cores_bandeiras. (Note a vírgula antes de 11:17. Esse comando de subconjunto diz ao R que nós queremos todas as linhas, mas só as colunas 11 a 17.)
  CorrectAnswer: cores_bandeiras <- bandeiras[, 11:17]
  AnswerTests: omnitest(correctExpr='cores_bandeiras <- bandeiras[, 11:17]')
  Hint: cores_bandeiras <- bandeiras[, 11:17] vai fazer o que é preciso.

- Class: cmd_question
  Output: Use a função head() para olhar as 6 primeiras linhas de cores_bandeiras.
  CorrectAnswer: head(cores_bandeiras)
  AnswerTests: omnitest(correctExpr='head(cores_bandeiras)')
  Hint: head(cores_bandeiras) irá mostrar as seis primeiras linhas de cores_bandeiras.

- Class: cmd_question
  Output: Para obter uma lista contendo a soma de cada coluna de cores_bandeiras, chame a função lapply() com dois argumentos. O primeiro é o objeto no qual estamos fazendo o loop (cores_bandeiras) e o segundo é o nome da função que queremos aplicar à cada coluna (sum). Lembre-se que o segundo argumento é o nome da função, sem parenteses, etc.
  CorrectAnswer: lapply(cores_bandeiras, sum)
  AnswerTests: omnitest(correctExpr='lapply(cores_bandeiras, sum)')
  Hint: Use lapply(cores_bandeiras, sum) para retornar a soma de cada coluna.

- Class: text
  Output: Isso nos diz que das 194 bandeiras no nosso dataset, 153 contém a cor vermelha, 91 a cor verde, 99 contém azul, etc.

- Class: cmd_question
  Output: O resultado é uma lista, já que lapply() sempre retorna uma lista. Cada elemento dessa lista tem tamanho um, então o resultado pode ser simplificado em um vetor chamando sapply() ao invés de lapply(). Tente isso agora.
  CorrectAnswer: sapply(cores_bandeiras, sum)
  AnswerTests: omnitest(correctExpr='sapply(cores_bandeiras, sum)')
  Hint: Use sapply(cores_bandeiras, sum) para retornar um vetor de somas de coluna.

- Class: text
  Output: Talvez seja mais informativo encontrar a proporção de bandeiras (de 194) contendo cada cor. Já que cada coluna é só um monte de 1s e 0s, a média artimética de cada coluna dará a proporção de 1s. (Se você não entender o porquê,pense em uma situação mais simples em que temos três 1s e dois 0s -- (1 + 1 + 1 + 0 + 0)/5 = 3/5 = 0.6).

- Class: cmd_question
  Output: Use sapply() para aplicar a função mean() em cada coluna de cores_bandeiras. Lembre-se que o segundo argumento para sapply() deve apenas especificar o nome da função que você quer aplicar.
  CorrectAnswer: sapply(cores_bandeiras, mean)
  AnswerTests: omnitest(correctExpr='sapply(cores_bandeiras, mean)')
  Hint: sapply(cores_bandeiras, mean) vai funcionar!

- Class: text
  Output: Nos exemplos que vimos até agora, sapply() conseguiu simplificar o resultado em um vetor. Isso é porque cada elemento da lista retornada por lapply() era um vetor de tamanho um. Lembre-se que sapply() retorna uma matriz quando cada elemento retornado por lapply() é um vetor  de mesmo tamanho (> 1).

- Class: cmd_question
  Output: Para ilustrar isso, vamos extrair as colunas 19 a 23 do dataset bandeiras e armazenar o resultado em um novo data frame chamado formas_bandeiras. formas_bandeiras <- bandeiras[, 19:23] vai resolver.
  CorrectAnswer: formas_bandeiras <- bandeiras[, 19:23]
  AnswerTests: omnitest(correctExpr='formas_bandeiras <- bandeiras[, 19:23]')
  Hint: formas_bandeiras <- bandeiras[, 19:23] salvará as colunas 19 a 23 em uma nova variável.

- Class: text
  Output: Cada uma dessas colunas (variáveis) representa o número de vezes que uma forma aparece na bandeira de um país. Estamos interessados nos números mínimo e máximo que cada forma aparece.

- Class: cmd_question
  Output: A função range() retorna o mínimo e máximo do seu primeiro argumento, que deve ser um vetor numérico. Use lapply() para aplicar a função range() a cada coluna de  formas_bandeiras. Não se preocupe em armazenar o resultado em uma nova variável. Já sabemos que lapply() sempre retorna uma lista.
  CorrectAnswer: lapply(formas_bandeiras, range)
  AnswerTests: omnitest(correctExpr='lapply(formas_bandeiras, range)')
  Hint: Tente lapply(formas_bandeiras, range) para aplicar a função range()  a cada coluna de  formas_bandeiras.

- Class: cmd_question
  Output: Faça a mesma operação, mas usando sapply() e armazene o resultado em uma variável chamada mat_formas.
  CorrectAnswer: mat_formas <- sapply(formas_bandeiras, range)
  AnswerTests: omnitest(correctExpr='mat_formas <- sapply(formas_bandeiras, range)')
  Hint: mat_formas <- sapply(formas_bandeiras, range) will apply the range() function to each column of formas_bandeiras and store the result in mat_formas.

- Class: cmd_question
  Output: View the contents of mat_formas.
  CorrectAnswer: mat_formas
  AnswerTests: any_of_exprs('mat_formas', 'print(mat_formas)')
  Hint: Type mat_formas to view its contents.

- Class: text
  Output: Each column of mat_formas gives the minimum (row 1) and maximum (row 2) number of times its respective shape appears in different bandeiras.

- Class: cmd_question
  Output: Use the class() function to confirm that mat_formas is a matrix.
  CorrectAnswer: class(mat_formas)
  AnswerTests: omnitest(correctExpr='class(mat_formas)')
  Hint: class(mat_formas) returns the class of mat_formas.

- Class: text
  Output: As we've seen, sapply() always attempts to simplify the result given by lapply(). It has been successful in doing so for each of the examples we've looked at so far. Let's look at an example where sapply() can't figure out how to simplify the result and thus returns a list, no different from lapply().

- Class: cmd_question
  Output: When given a vector, the unique() function returns a vector with all duplicate elements removed. In other words, unique() returns a vector of only the 'unique' elements. To see how it works, try unique(c(3, 4, 5, 5, 5, 6, 6)).
  CorrectAnswer: unique(c(3, 4, 5, 5, 5, 6, 6))
  AnswerTests: omnitest(correctExpr='unique(c(3, 4, 5, 5, 5, 6, 6))')
  Hint: Do unique(c(3, 4, 5, 5, 5, 6, 6)) to see how the unique() function works.

- Class: cmd_question
  Output: We want to know the unique values for each variable in the bandeiras dataset. To accomplish this, use lapply() to apply the unique() function to each column in the bandeiras dataset, storing the result in a variable called unique_vals.
  CorrectAnswer: unique_vals <- lapply(bandeiras, unique)
  AnswerTests: omnitest(correctExpr='unique_vals <- lapply(bandeiras, unique)')
  Hint: Try unique_vals <- lapply(bandeiras, unique).

- Class: cmd_question
  Output: Print the value of unique_vals to the console.
  CorrectAnswer: unique_vals
  AnswerTests: any_of_exprs('unique_vals', 'print(unique_vals)')
  Hint: Type unique_vals to view its contents.

- Class: cmd_question
  Output: "Since unique_vals is a list, you can use what you've learned to determine the length of each element of unique_vals (i.e. the number of unique values for each variable). Simplify the result, if possible. Hint: Apply the length() function to each element of unique_vals."
  CorrectAnswer: sapply(unique_vals, length)
  AnswerTests: omnitest(correctExpr='sapply(unique_vals, length)')
  Hint: Apply the length() function to each element of the unique_vals list using sapply(). Remember, no parentheses after the name of the function you are applying (i.e. length).

- Class: text
  Output: The fact that the elements of the unique_vals list are all vectors of *different* length poses a problem for sapply(), since there's no obvious way of simplifying the result.

- Class: cmd_question
  Output: Use sapply() to apply the unique() function to each column of the bandeiras dataset to see that you get the same unsimplified list that you got from lapply().
  CorrectAnswer: sapply(bandeiras, unique)
  AnswerTests: omnitest(correctExpr='sapply(bandeiras, unique)')
  Hint: Use sapply(bandeiras, unique) to apply the unique function to each column of bandeiras, failing to simplify the result.

- Class: text
  Output: Occasionally, you may need to apply a function that is not yet defined, thus requiring you to write your own. Writing functions in R is beyond the scope of this lesson, but let's look at a quick example of how you might do so in the context of loop functions.

- Class: text
  Output: Pretend you are interested in only the second item from each element of the unique_vals list that you just created. Since each element of the unique_vals list is a vector and we're not aware of any built-in function in R that returns the second element of a vector, we will construct our own function.

- Class: cmd_question
  Output: lapply(unique_vals, function(elem) elem[2]) will return a list containing the second item from each element of the unique_vals list. Note that our function takes one argument, elem, which is just a 'dummy variable' that takes on the value of each element of unique_vals, in turn.
  CorrectAnswer: lapply(unique_vals, function(elem) elem[2])
  AnswerTests: calculates_same_value('lapply(unique_vals, function(elem) elem[2])')
  Hint: Use lapply(unique_vals, function(elem) elem[2]) to return a list containing the second item from each element of the unique_vals list.

- Class: text
  Output: The only difference between previous examples and this one is that we are defining and using our own function right in the call to lapply(). Our function has no name and disappears as soon as lapply() is done using it. So-called 'anonymous functions' can be very useful when one of R's built-in functions isn't an option.

- Class: text
  Output: In this lesson, you learned how to use the powerful lapply() and sapply() functions to apply an operation over the elements of a list. In the next lesson, we'll take a look at some close relatives of lapply() and sapply().

- Class: mult_question
  Output: Would you like to inform someone about your successful completion of this lesson?
  CorrectAnswer: NULL
  AnswerChoices: Yes; No
  AnswerTests: notify()
  Hint: NULL
